#include "dma.h"
// A sleep handler which will be called when there is no communication taking place
void sleep_handler(void)
{
  __WFE();
  __SEV();
  __WFE();
}

void uart_event_handler(struct nrf_serial_s const *p_serial, nrf_serial_event_t event);

NRF_SERIAL_DRV_UART_CONFIG_DEF(m_uart0_drv_config,
                               RX_PIN_NUMBER, TX_PIN_NUMBER, // TX pin and rx pin 
                               RTS_PIN_NUMBER, CTS_PIN_NUMBER, // RTS and CTS pin
                               NRF_UART_HWFC_ENABLED, NRF_UART_PARITY_EXCLUDED, // Hardware flow control is disabled because we are not using a very high baud rate
                               NRF_UARTE_BAUDRATE_115200, // UART baud rate is defined using this constant
                               UART_DEFAULT_CONFIG_IRQ_PRIORITY); //  default interrupt priority is set to 7 which is the lowest and will be processed once higher priority interrupts are executed

// Now we need to define the size of fifo, if this is too small then receiving more data then this size will cause the fifo overflow so adjust it according to your application
#define SERIAL_FIFO_TX_SIZE DATASIZE // Fifo for TX
#define SERIAL_FIFO_RX_SIZE DATASIZE// FIFO for RX 



// Create a queue and assign it the fifo sizes
NRF_SERIAL_QUEUES_DEF(serial_queues, SERIAL_FIFO_TX_SIZE, SERIAL_FIFO_RX_SIZE);


// This is the minimum buffer size and interrupts will depend on its size, for e.g if the rx buffer size is 1, then upon receiving every one character an interrupt will be generated
// Adjust it according to your requirements
#define SERIAL_BUFF_TX_SIZE 3
#define SERIAL_BUFF_RX_SIZE 3


// Now create a buffer and assign it size of RX buffer and TX buffer
NRF_SERIAL_BUFFERS_DEF(serial_buffs, SERIAL_BUFF_TX_SIZE, SERIAL_BUFF_RX_SIZE);


// Create a main configuration handle and pass it all the configurations created above
// Parameters are: name of configuration, Mode of operation i.e blocking - non-blocking or - DMA mode,
// serial queue configuration address, serial buffers address, event handler which will be called on interrupts,
// Sleep handler which will be called if the device is not using serial comm so it can go into sleep mode, we can pass it NULL value as well

NRF_SERIAL_CONFIG_DEF(serial_config, NRF_SERIAL_MODE_DMA,
                      &serial_queues, &serial_buffs, uart_event_handler, sleep_handler);




// Create a UART handle and assign it the hardware UART, 0 for nrf52832 and it can be 0 or 1 for nrf52840
NRF_SERIAL_UART_DEF(serial_uart, 0);



// This event handler will be called whenever an interrupt is triggered by the UART module

void uart_event_handler(struct nrf_serial_s const *p_serial, nrf_serial_event_t event)
{
    ret_code_t err_code; // A variable to hold the error code value

    uint8_t c[4]; // defined an array of 4 char type values




// check which event was generated by the interrupt
    switch(event)
    {
		// if this event occured then it means the transmission of data is succesfully completed and we 
		// can now update our user or perform something else 
      case NRF_SERIAL_EVENT_TX_DONE:
      bsp_board_led_invert(11);// a function to toggle the led 1
      break;

	  // if this event occured it means that some data is available to be read, its size depends on the buffer size as mentioned above.
      case NRF_SERIAL_EVENT_RX_DATA:
      bsp_board_led_invert(11); //toggle the LED 4 on the board showing some data is received
		
	  // Read the data from the serial port and save it into the array 	
      err_code = nrf_serial_read(&serial_uart, &c, sizeof(c), NULL, 100);
      APP_ERROR_CHECK(err_code); // check if some error occured during reading
	  
	  // We can also use type casting to drop the error code like i did below by using (void) before the function
      (void)nrf_serial_write(&serial_uart, &c, sizeof(c), NULL, 100); // a function to transmit the data over uart
      (void)nrf_serial_flush(&serial_uart, 0); // call this function to clear the buffers from the last received data 
      break;

      default:
	  // do nothing if none of the above event is occured
      break;
    
    }
  }